`include "constants.h"
`include "discipline.h"

module MGAP(n1, n2);
    inout n1, n2;
    electrical n1, n2, n3;

    parameter real w = 200.0 from (0:inf); // Ширина линии (микрометры)
    parameter real h = 100.0 from (0:inf); // Толщина подложки (микрометры)
    parameter real er = 12.9 from (0:inf); // Диэлектрическая проницаемость
    parameter real s = 50.0 from (0:inf);  // Ширина зазора (микрометры)

    real w_h, s_w, m0, k0, m_e, k_e, C_odd_per_w, C_even_per_w;
    real C_odd_96, C_even_96, C_odd, C_even, Cp, Cg;
    real w_meters;

    analog begin
        // Проверка допустимых диапазонов
        w_h = w / h;
        s_w = s / w;

        if (w_h < 0.5 || w_h > 2.0) begin
            $strobe("Ошибка: Отношение w/h должно быть в диапазоне [0.5, 2.0]");
        end
        if (s_w < 0.1 || s_w > 1.0) begin
            $strobe("Ошибка: Отношение s/w должно быть в диапазоне [0.1, 1.0]");
        end

        // 1. Расчет коэффициентов для C_odd
        m0 = w_h * (0.619 * ln(w_h)/ln(10) - 0.3853);
        k0 = 4.26 - 1.453 * ln(w_h)/ln(10);

        // 2. Расчет коэффициентов для C_even
        m_e = 1.565 / pow(w_h, 0.16) - 1;
        k_e = (s_w <= 0.3) ? 2.043 * pow(w_h, 0.12) : 1.97 - 0.03 / w_h;

        // 3. Расчет погонных емкостей (пФ/м)
        C_odd_per_w = pow(s_w, m0) * exp(k0);  // Для нечетного режима
        C_even_per_w = 12 * pow(s_w, m_e) * exp(k_e);  // Для четного режима

        // 4. Пересчет в абсолютные значения (пФ)
        w_meters = w * 1e-6;  // Ширина в метрах
        C_odd_96 = C_odd_per_w * w_meters;
        C_even_96 = C_even_per_w * w_meters;

        // 5. Масштабирование для произвольной диэлектрической проницаемости
        C_odd = C_odd_96 * pow(er / 9.6, 0.8);
        C_even = C_even_96 * pow(er / 9.6, 0.9);

        // 6. Расчет параметров схемы
        Cp = C_even / 2;
        Cg = (C_odd - Cp) / 2;

        // Модель эквивалентной схемы: Cp на каждом узле к земле, Cg между узлами
        I(n1) <+ ddt(Cp * 1e-12 * V(n1));
        I(n2) <+ ddt(Cp * 1e-12 * V(n2));
        I(n1, n2) <+ ddt(Cg * 1e-12 * V(n1, n2));
    end
endmodule