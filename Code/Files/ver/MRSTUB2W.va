`include "constants.h"
`include "discipline.h"

module MRSTUB2W(p);
    inout p;
    electrical p;

    parameter real er = 12.9;    // Относительная диэлектрическая проницаемость
    parameter real h = 0.1e-3;   // Высота подложки [м]
    parameter real w1 = 100e-6;  // Начальная ширина линии [м]
    parameter real theta = 30.0;  // Угол в градусах (от 30 до 160)
    parameter real Ro = 1000.e-6; // Радиус (м)
    parameter real length = Ro;   // Длина линии [м]

    // Константы
    parameter real c_mps = 299792458; // Скорость света
    parameter real pi = 3.141592653589793; // Число π

    // Внутренние узлы
    electrical node0, node1, node2, node3, node4, node5, node6, node7, node8, node9;
    electrical node10, node11, node12, node13, node14, node15, node16, node17, node18, node19;

    real w[0:19];               // Массив ширин для каждого узла
    real wh_ratio[0:19];        // Массив отношения w/h
    real e_eff[0:19];           // Массив эффективной диэлектрической проницаемости
    real Z0[0:19];              // Массив характеристического сопротивления
    real L_total[0:19];         // Массив погонной индуктивности (Гн/м)
    real C_total[0:19];         // Массив погонной емкости (Ф/м)
    real L_seg_SI[0:18];        // Индуктивность на сегмент (Гн) - 19 элементов
    real C_seg_SI[0:19];        // Емкость на сегмент (Ф) - 20 элементов

    integer i;
    real w2;                     // Вычисленная ширина w2
    real Ri;                     // Внутренний радиус
    real Ro_corrected;           // Скорректированный радиус
    real segment_length;         // Длина одного сегмента

    analog begin
        // Расчет внутреннего радиуса Ri
        Ri = w1 / (2 * sin(theta * pi / 360.0));  // theta/2 в радианах

        // Корректировка радиуса
        Ro_corrected = Ro - Ri;

        // Расчет w2
        w2 = w1 + 2.0 * Ro_corrected * sin(theta * pi / 360.0);  // sin(theta/2)

        // Длина одного сегмента
        segment_length = length / 19;

        // Линейное изменение ширины от w1 до w2 через 20 узлов
        for (i = 0; i <= 19; i = i + 1) begin
            w[i] = w1 + (w2 - w1) * i / 19;

            // Расчет отношения w/h
            wh_ratio[i] = w[i] / h;

            // Расчет эффективной диэлектрической проницаемости
            if (wh_ratio[i] <= 1.0) begin
                e_eff[i] = (er + 1.0)/2.0 + (er - 1.0)/2.0 * (
                    1.0 / sqrt(1.0 + 12.0/wh_ratio[i]) + 0.04 * pow(1.0 - wh_ratio[i], 2.0) );
            end else begin
                e_eff[i] = (er + 1.0)/2.0 + (er - 1.0)/2.0 * (
                    1.0 / sqrt(1.0 + 12.0/wh_ratio[i]) );
            end

            // Расчет характеристического сопротивления
            if (wh_ratio[i] <= 1.0) begin
                Z0[i] = (60.0 / sqrt(e_eff[i])) * ln(8.0/wh_ratio[i] + 0.25*wh_ratio[i]);
            end else begin
                Z0[i] = (120.0 * pi) / (sqrt(e_eff[i]) * (wh_ratio[i] + 1.393 + 0.667*ln(wh_ratio[i] + 1.444)));
            end

            // Расчет погонных L и C (на метр)
            L_total[i] = (Z0[i] * sqrt(e_eff[i])) / c_mps;  // Гн/м
            C_total[i] = (sqrt(e_eff[i])) / (Z0[i] * c_mps); // Ф/м
        end

        // Расчет индуктивностей для сегментов (19 элементов)
        for (i = 0; i <= 18; i = i + 1) begin
            L_seg_SI[i] = (L_total[i] * segment_length);  // Индуктивность на сегмент
        end

        // Расчет емкостей для узлов (20 элементов)
        for (i = 0; i <= 19; i = i + 1) begin
            C_seg_SI[i] = (C_total[i] * segment_length);  // Емкость на сегмент
        end

        // Подключение портов
        V(p, node0) <+ 0;

        // Индуктивные сегменты (19 элементов)
        V(node0, node1) <+ L_seg_SI[0] * ddt(I(node0, node1));
        V(node1, node2) <+ L_seg_SI[1] * ddt(I(node1, node2));
        V(node2, node3) <+ L_seg_SI[2] * ddt(I(node2, node3));
        V(node3, node4) <+ L_seg_SI[3] * ddt(I(node3, node4));
        V(node4, node5) <+ L_seg_SI[4] * ddt(I(node4, node5));
        V(node5, node6) <+ L_seg_SI[5] * ddt(I(node5, node6));
        V(node6, node7) <+ L_seg_SI[6] * ddt(I(node6, node7));
        V(node7, node8) <+ L_seg_SI[7] * ddt(I(node7, node8));
        V(node8, node9) <+ L_seg_SI[8] * ddt(I(node8, node9));
        V(node9, node10) <+ L_seg_SI[9] * ddt(I(node9, node10));
        V(node10, node11) <+ L_seg_SI[10] * ddt(I(node10, node11));
        V(node11, node12) <+ L_seg_SI[11] * ddt(I(node11, node12));
        V(node12, node13) <+ L_seg_SI[12] * ddt(I(node12, node13));
        V(node13, node14) <+ L_seg_SI[13] * ddt(I(node13, node14));
        V(node14, node15) <+ L_seg_SI[14] * ddt(I(node14, node15));
        V(node15, node16) <+ L_seg_SI[15] * ddt(I(node15, node16));
        V(node16, node17) <+ L_seg_SI[16] * ddt(I(node16, node17));
        V(node17, node18) <+ L_seg_SI[17] * ddt(I(node17, node18));
        V(node18, node19) <+ L_seg_SI[18] * ddt(I(node18, node19));

        // Емкостные сегменты (20 элементов)

        I(node1) <+ C_seg_SI[1] * ddt(V(node1));
        I(node2) <+ C_seg_SI[2] * ddt(V(node2));
        I(node3) <+ C_seg_SI[3] * ddt(V(node3));
        I(node4) <+ C_seg_SI[4] * ddt(V(node4));
        I(node5) <+ C_seg_SI[5] * ddt(V(node5));
        I(node6) <+ C_seg_SI[6] * ddt(V(node6));
        I(node7) <+ C_seg_SI[7] * ddt(V(node7));
        I(node8) <+ C_seg_SI[8] * ddt(V(node8));
        I(node9) <+ C_seg_SI[9] * ddt(V(node9));
        I(node10) <+ C_seg_SI[10] * ddt(V(node10));
        I(node11) <+ C_seg_SI[11] * ddt(V(node11));
        I(node12) <+ C_seg_SI[12] * ddt(V(node12));
        I(node13) <+ C_seg_SI[13] * ddt(V(node13));
        I(node14) <+ C_seg_SI[14] * ddt(V(node14));
        I(node15) <+ C_seg_SI[15] * ddt(V(node15));
        I(node16) <+ C_seg_SI[16] * ddt(V(node16));
        I(node17) <+ C_seg_SI[17] * ddt(V(node17));
        I(node18) <+ C_seg_SI[18] * ddt(V(node18));
        I(node19) <+ C_seg_SI[19] * ddt(V(node19));
    end
endmodule